from flask import request, render_template, Blueprint, redirect, jsonify, make_response
from short.databases import session
from short.forms import ShortyForm
from short.models import URLS
from .utils import encode, url_regex, name_regex, parsing_url
import uuid

api = Blueprint('', __name__)


def create_short_url(original_url, unique_id):
    original_url += f'[{unique_id}]'
    converted = sum([ord(_) for _ in original_url])
    return encode(converted)


@api.route('/', methods=['GET', 'POST'])
def main():
    form = ShortyForm(request.form)
    if request.method == 'POST':
        if not form.validate():
            return render_template('main.html', form=form, msg='다시 입력해주세요')

        original_url = request.form['url']

        short_url = request.form.get('name')
        is_unique = session.query(URLS).filter(URLS.short_url == short_url).scalar()
        if is_unique:
            return render_template('main.html', form=form, msg='해당 단축 url이 이미 존재합니다.')

        unique_id = uuid.uuid4()
        is_autogenerated = False
        if not short_url:
            is_autogenerated = True
            short_url = create_short_url(original_url, unique_id)

        new_url = URLS(id=unique_id, original_url=original_url, short_url=short_url, is_autogenerated=is_autogenerated)
        session.add(new_url)
        session.commit()
        urls = session.query(URLS).all()
        return render_template('main.html', form=form, msg=short_url, urls=urls)

    urls = session.query(URLS).all()
    return render_template('main.html', form=form, urls=urls)


@api.route('/urls', methods=['GET'])
def get_urls():
    urls = session.query(URLS).all()
    if not urls:
        return jsonify(urls=[])
    return jsonify(urls=[dict(original_url=row.original_url,
                              short_url=row.short_url)
                         for row in urls])


@api.route('/urls', methods=['POST'])
def get_short_url():
    data = request.get_json(silent=True)
    if not data.get('url'):
        return make_response(jsonify(msg='url이 없습니다'), 422)

    try:
        validate_url_and_name(data)
    except ValueError as e:
        return make_response(jsonify(msg=str(e)), 422)

    original_url = data['url']
    short_url = data.get('name')

    unique_id = uuid.uuid4()
    is_autogenerated = False

    if not short_url:
        short_url = create_short_url(original_url, unique_id)
        is_autogenerated = True

    url_exists = session.query(URLS) \
        .filter(URLS.short_url == short_url) \
        .first()

    if url_exists:
        return make_response(jsonify(msg=f'{short_url} exists'), 422)

    new_url = URLS(id=unique_id, original_url=original_url, short_url=short_url, is_autogenerated=is_autogenerated)
    session.add(new_url)
    session.commit()
    return jsonify(original_url=original_url, short_url=short_url)


@api.route('/<string:short_url>', methods=['GET'])
def url_converter(short_url):
    url = session.query(URLS).filter(URLS.short_url == short_url).first()
    if not url:
        return make_response(jsonify(msg='url is missing'), 404)
    return redirect(url.original_url)


def validate_url_and_name(data):
    regex = url_regex()
    result = regex.search(data['url'])
    parse_result = parsing_url(data['url'])
    if result is None:
        if not parse_result:
            raise ValueError('url 주소가 잘못된 형식입니다.')

    if data.get('name'):
        regex = name_regex()
        result = regex.search(data['name'])
        if result is not None:
            raise ValueError('단축 url에 특수문자가 포함되어 있습니다.')

